{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Prefect Managed File Transfer","text":"<p>Turn a prefect.io server into a managed file transfer solution. UI and Programatic creation of cron style jobs (aka Flows!) to upload and download files easily between servers. Support local, SFTP remotes plus any Cloud storage supported by rclone -  so thats aws, azure, google, sharepoint, and many more out of the box.</p> <p>Using prefect for managed file transfer means retries, logging, multi node and high availability come as standard - turning prefect into a reliable enterprise ready file transfer solution. </p> <p>This package is not the fastest solution to move files around, but it prioritises reliability and ease of use, making it an excellent choice for replacing both quick cron job copy scripts and enterprise managed file transfer applicances.</p> <p>Key features</p> <ul> <li>Copy and move files between almost any storage system easily.</li> <li>Reliable file moving with checksumming, file size checking etc.</li> <li>Smart and safe moving - settings to allow/block overwriting and to only copy files if they are new or changed.</li> <li>Unzip/Untar compressed folders after downloading them.</li> <li>Repath files as you move them.</li> <li>Complex filtering and ordering of files - by path, age, size etc. Pattern matching with regular expressions.</li> <li>Leverage Prefect.IO built in scheduling and orchestration capabilities:<ul> <li>Transfer files on complex cron schedules</li> <li>notifications on success/failure - slack, email, etc</li> <li>Highly available server architecture - database server + multi-node workers and front ends.</li> </ul> </li> <li>Available as a PyPi package for integration into existing self hosted and cloud prefect deployments, and as a docker image/appiance</li> </ul> <p>Example use cases:</p> <ul> <li>Once per day SSH into my database server and copy the latest *.bkup file to a central storage location.</li> <li>Monitor a local network share directory for new files and automatically upload them to a cloud storage bucket.</li> <li>Schedule a weekly job to synchronize files between two remote servers.</li> <li>Move log files from a SSH available web server older than 30 days to a cold storage location.</li> <li>Copy file yyyy-MM-dd.zip from a remote server, where yyyy-MM-dd matches todays date, to a local directory and then unzip it.</li> <li>Download any file in an S3 bucket larger than 1GB and store it in a local directory.</li> </ul>"},{"location":"#installation-local","title":"Installation - Local","text":"<p>Install <code>prefect-managedfiletransfer</code> with <code>pip</code>. (Requires an installation of Python 3.10+.)</p> <pre><code>pip install prefect-managedfiletransfer\n# or \nuv add prefect-managedfiletransfer\n</code></pre> <p>We recommend using a Python virtual environment manager such as uv, pipenv, conda or virtualenv.</p> <p>In one (venv) terminal start a prefect server with logs enabled</p> <pre><code>export PREFECT_LOGGING_LEVEL=\"INFO\"\nexport PREFECT_LOGGING_EXTRA_LOGGERS=\"prefect_managedfiletransfer\"\nprefect server start\n# OR uv run prefect server start\n</code></pre> <p>There are many ways to manage infrastructure and code with prefect - here we demonstate starting a local worker:</p> <pre><code>export PREFECT_API_URL=http://127.0.0.1:4200/api\n# or perhaps export PREFECT_API_URL=http://host.docker.internal:4200/api\nexport PREFECT_LOGGING_EXTRA_LOGGERS=\"prefect_managedfiletransfer\"\nexport PREFECT_LOGGING_LEVEL=\"INFO\"\n# [Optional] add all logs: export PREFECT_LOGGING_ROOT_LEVEL=\"INFO\"\n\n\nprefect worker start --pool 'default-pool' --type process\n\n# OR add a worker with config to spawn containers that can talk to the server API:\nPREFECT_API_URL=http://host.docker.internal:4200/api uv run prefect worker start --pool 'default-pool' --type=docker  \n</code></pre> <p>Install the blocks using the prefect CLI</p> <pre><code>prefect block register -m prefect_managedfiletransfer\n</code></pre> <p>And then deploy the flows. </p> <pre><code># deploy the flows to run locally\npython -m prefect_managedfiletransfer.deploy --local\n\n# OR deploy to run with a docker image - see deploy.py\npython -m prefect_managedfiletransfer.deploy --docker\n\n# or a version of the above using uv run:\nuv run python -m prefect_managedfiletransfer.deploy --local\nuv run python -m prefect_managedfiletransfer.deploy --docker\n</code></pre> <p>Visit the server UI http://localhost:4200. 1. Create 2 blocks, one source and one destination 2. On the deployments page start a <code>transfer_files_flow</code>. Configure your flow run to copy/move files between the 2 blocks.</p>"},{"location":"#installation-docker","title":"Installation - docker","text":"<p>Run prefect managed file transfer in a docker container, like an applicance. See Docker hub for a list of images</p> <p>Note this is ephemeral - prefect has lots of docs on how to setup a database server with it.</p> <pre><code># run prefect server in a self-removing container port-forwarded to your local machine\u2019s 4200 port:\ndocker run --rm -it -p 4200:4200 managedfiletransfer/prefect-managedfiletransfer:latest\n</code></pre>"},{"location":"#components","title":"Components","text":"<p>Flows</p> <ul> <li>transfer_files_flow - a fully featured flow for transferring files between different storage locations.</li> <li>upload_file_flow - a flow for uploading a file to a remote server. Supports pattern matching by date</li> </ul> <p>Blocks</p> <ul> <li>ServerWithBasicAuthBlock - A block for connecting to a server using basic authentication.</li> <li>ServerWithPublicKeyAuthBlock - A block for connecting to a server using public key authentication.</li> <li>RCloneConfigFileBlock - A block for managing RClone configuration files.</li> </ul> <p>Tasks</p> <ul> <li>list_remote_files_task - A task for listing files in a remote directory.</li> <li>download_file_task - A task for downloading a single file from a remote server.</li> <li>upload_file_task - A task for uploading a single file to a remote server.</li> <li>[TODO] delete_file_task</li> </ul> <p></p>"},{"location":"#feedback","title":"Feedback","text":"<p>If you encounter any bugs while using <code>prefect-managedfiletransfer</code>, feel free to open an issue in the prefect-managedfiletransfer repository.</p> <p>Feel free to star or watch <code>prefect-managedfiletransfer</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-managedfiletransfer</code>, please propose changes through a pull request from a fork of the repository.</p> <p>Here are the steps:</p> <ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code># install uv first, then\nuv sync\n</code></pre></li> </ol> <p>You can also access all the prefect CLI tooling inside a uv managed venv <pre><code>uv venv\nsource .venv/bin/activate\nprefect server start\n</code></pre></p> <ol> <li>Make desired changes</li> <li>Add tests</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <pre><code>pre-commit install\n</code></pre></li> <li>use the build script to run all the checks and tests:</li> </ol> <p><pre><code>./build.sh\n</code></pre> 8. <code>git commit</code>, <code>git push</code>, and create a pull request</p>"},{"location":"blocks_catalog/","title":"Blocks Catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-managedfiletransfer</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud, first install the required packages, then <pre><code>prefect block register -m prefect_managedfiletransfer\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"blocks_catalog/#serverwithbasicauthblock-module","title":"[Serverwithbasicauthblock Module][prefect_managedfiletransfer.ServerWithBasicAuthBlock]","text":"<p>[ServerWithBasicAuthBlock][prefect_managedfiletransfer.ServerWithBasicAuthBlock.ServerWithBasicAuthBlock]</p> <p>A connection to a remote server with basic authentication.</p> <p>To load the ServerWithBasicAuthBlock: <pre><code>from prefect import flow\nfrom prefect_managedfiletransfer.ServerWithBasicAuthBlock import ServerWithBasicAuthBlock\n\n@flow\ndef my_flow():\n    my_block = ServerWithBasicAuthBlock.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"blocks_catalog/#serverwithpublickeyauthblock-module","title":"[Serverwithpublickeyauthblock Module][prefect_managedfiletransfer.ServerWithPublicKeyAuthBlock]","text":"<p>[ServerWithPublicKeyAuthBlock][prefect_managedfiletransfer.ServerWithPublicKeyAuthBlock.ServerWithPublicKeyAuthBlock]</p> <p>Block for storing SFTP server details with public key authentication. Attributes:     username: The username for SFTP authentication.     private_key: The private key for SFTP authentication, stored as a SecretStr.     host: The hostname or IP address of the SFTP server.     port: The port number for SFTP, default is 22.</p> <p>To load the ServerWithPublicKeyAuthBlock: <pre><code>from prefect import flow\nfrom prefect_managedfiletransfer.ServerWithPublicKeyAuthBlock import ServerWithPublicKeyAuthBlock\n\n@flow\ndef my_flow():\n    my_block = ServerWithPublicKeyAuthBlock.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"blocks_catalog/#rcloneconfigfileblock-module","title":"[Rcloneconfigfileblock Module][prefect_managedfiletransfer.RCloneConfigFileBlock]","text":"<p>[RCloneConfigFileBlock][prefect_managedfiletransfer.RCloneConfigFileBlock.RCloneConfigFileBlock]</p> <p>Block for storing RClone configuration file contents. This block is used to store the contents of an RClone configuration file, which can be used to configure RClone for file transfers. The block is updated with tokends when they are refreshed, allowing for dynamic updates to the RClone configuration.</p> <p>Generate a config locally with <code>rclone config create my_sharepoint onedrive</code> like below, then save the contents in a block with remote_name=my_sharepoint,config_file_contents= [my_sharepoint] type = onedrive token = {\"access_token\":\"...\",\"token_type\":\"Bearer\",\"refresh_token\":\"...\",\"expiry\":\"2000-00-00T00:00:00.000000000Z\"} drive_id = b!-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa drive_type = documentLibrary.</p> <p>To load the RCloneConfigFileBlock: <pre><code>from prefect import flow\nfrom prefect_managedfiletransfer.RCloneConfigFileBlock import RCloneConfigFileBlock\n\n@flow\ndef my_flow():\n    my_block = RCloneConfigFileBlock.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre></p>"},{"location":"flows/","title":"Flows","text":""},{"location":"flows/#prefect_managedfiletransfer.transfer_files_flow","title":"<code>prefect_managedfiletransfer.transfer_files_flow</code>","text":""},{"location":"flows/#prefect_managedfiletransfer.transfer_files_flow-classes","title":"Classes","text":""},{"location":"flows/#prefect_managedfiletransfer.transfer_files_flow-functions","title":"Functions","text":""},{"location":"flows/#prefect_managedfiletransfer.transfer_files_flow.transfer_files_flow","title":"<code>transfer_files_flow</code>  <code>async</code>","text":"<p>Transfers files from a source to a destination based on the provided matchers and mapping. Args:     source_block: The source block to transfer files from.     destination_block: The destination block to transfer files to.     source_file_matchers: List of file matcheing patterns to find and filter files in the source.     path_mapping: List of file-to-folder mappings for transferring files.     destination_folder: The path of the folder in destination_block where files will be transferred.     update_only_if_newer_mode: If true, skip files that are newer on the destination.     overwrite: If true, overwrite existing files in the destination.     check_for_space: If true, check if there is enough space on the destination before transferring.     check_for_space_overhead: Amount of extra space to reserve on the destination (in bytes).     mode: Copy or Move transfer mode.     reference_date: defaults to now() in UTC - used to filter files based on modification time, and for pattern replacement in file names Returns:     A list of the Paths of transferred files.</p> Source code in <code>prefect_managedfiletransfer/transfer_files_flow.py</code> <pre><code>@flow(\n    name=CONSTANTS.FLOW_NAMES.TRANSFER_FILES,\n    log_prints=True,\n    flow_run_name=_generate_flow_run_name,\n    retries=2,\n    retry_delay_seconds=60 * 20,  # retry every 20 minutes\n    timeout_seconds=60 * 30,  # timeout after 30 minutes\n)\nasync def transfer_files_flow(\n    source_block: TransferBlockType,\n    destination_block: TransferBlockType,\n    source_file_matchers: list[FileMatcher] = [FileMatcher()],\n    path_mapping: list[FileToFolderMapping] = [],\n    destination_folder: Path = Path(\".\"),\n    update_only_if_newer_mode: bool = False,\n    overwrite: bool = False,\n    check_for_space: bool = True,\n    check_for_space_overhead: int = 2 * 1024 * 1024 * 1024,  # 2GB overhead\n    mode: TransferType = TransferType.Copy,\n    reference_date: datetime | None = None,\n) -&gt; list:\n    \"\"\"\n    Transfers files from a source to a destination based on the provided matchers and mapping.\n    Args:\n        source_block: The source block to transfer files from.\n        destination_block: The destination block to transfer files to.\n        source_file_matchers: List of file matcheing patterns to find and filter files in the source.\n        path_mapping: List of file-to-folder mappings for transferring files.\n        destination_folder: The path of the folder in destination_block where files will be transferred.\n        update_only_if_newer_mode: If true, skip files that are newer on the destination.\n        overwrite: If true, overwrite existing files in the destination.\n        check_for_space: If true, check if there is enough space on the destination before transferring.\n        check_for_space_overhead: Amount of extra space to reserve on the destination (in bytes).\n        mode: Copy or Move transfer mode.\n        reference_date: defaults to now() in UTC - used to filter files based on modification time, and for pattern replacement in file names\n    Returns:\n        A list of the Paths of transferred files.\n    \"\"\"\n    if not source_file_matchers:\n        raise ValueError(\"No source file matchers provided\")\n\n    if reference_date is None:\n        reference_date = datetime.now(timezone.utc)\n\n    # cannot both be local file systems\n    if not isinstance(source_block, LocalFileSystem) and not isinstance(\n        destination_block, LocalFileSystem\n    ):\n        raise ValueError(\n            \"Cannot transfer files between two remote file systems. One must be local.\"\n        )\n\n    source_type = map_block_to_remote_type(source_block)\n    destination_type = map_block_to_remote_type(destination_block)\n    rclone_source_config = (\n        RCloneConfigSavedInPrefect(source_block)\n        if isinstance(source_block, RCloneConfigFileBlock)\n        else None\n    )\n    rclone_destination_config = (\n        RCloneConfigSavedInPrefect(destination_block)\n        if isinstance(destination_block, RCloneConfigFileBlock)\n        else None\n    )\n\n    source_files: list[RemoteAsset] = []\n    for matcher in source_file_matchers:\n        files = await list_remote_files_task(\n            source_block,\n            source_type,\n            matcher,\n            rclone_source_config,\n            reference_date,\n        )\n        source_files.extend(files)\n\n    basepath_str = (\n        destination_block.basepath if hasattr(destination_block, \"basepath\") else None\n    )\n\n    resolved_destination_with_basepath = PathUtil.resolve_path(\n        destination_type, basepath_str, destination_folder\n    )\n\n    source_destination_pairs = FileToFolderMapping.apply_mappings(\n        path_mapping, source_files, resolved_destination_with_basepath\n    )\n\n    transferred = []\n    for remote_asset, target_file_path in source_destination_pairs:\n        if destination_type == RemoteConnectionType.LOCAL:\n            downloaded_file = await download_file_task(\n                source_block,\n                source_type,\n                remote_asset,\n                target_file_path,\n                update_only_if_newer_mode,\n                overwrite,\n                mode,\n                rclone_source_config,\n                check_for_space,\n                check_for_space_overhead,\n                reference_date,\n            )\n            transferred.append(downloaded_file)\n        else:\n            upload_result = await upload_file_task(\n                remote_asset,\n                destination_block,\n                destination_type,\n                target_file_path,\n                update_only_if_newer_mode,\n                overwrite,\n                mode,\n                rclone_config=rclone_destination_config,\n                check_for_space=check_for_space,\n                check_for_space_overhead=check_for_space_overhead,\n                reference_date=reference_date,\n            )\n            transferred.append(upload_result)\n\n    logger.info(f\"Transfer completed. {len(transferred)} files processed\")\n\n    return transferred\n</code></pre>"},{"location":"flows/#prefect_managedfiletransfer.upload_file_flow","title":"<code>prefect_managedfiletransfer.upload_file_flow</code>","text":""},{"location":"flows/#prefect_managedfiletransfer.upload_file_flow-classes","title":"Classes","text":""},{"location":"flows/#prefect_managedfiletransfer.upload_file_flow-functions","title":"Functions","text":""},{"location":"flows/#prefect_managedfiletransfer.upload_file_flow.upload_file_flow","title":"<code>upload_file_flow</code>  <code>async</code>","text":"<p>Publish a single file to a destination, e.g. upload an image to a website or copy a file to a local shared public folder</p> <p>Parameters:</p> Name Type Description Default <code>source_folder</code> <code>Path</code> <p>The folder where the file to upload is located.</p> required <code>pattern_to_upload</code> <code>str</code> <p>The pattern of the file to upload, e.g. \"*.jpg\".</p> required <code>destination_file</code> <code>Path</code> <p>The destination file path where the file will be uploaded.</p> required <code>destination_block_or_blockname</code> <code>ServerWithBasicAuthBlock | ServerWithPublicKeyAuthBlock | LocalFileSystem | RCloneConfigFileBlock | str</code> <p>The destination block or block name where the file will be uploaded.</p> required <code>update_only_if_newer_mode</code> <code>bool</code> <p>If true, skip files that are newer on the destination.</p> <code>False</code> <code>mode</code> <code>TransferType</code> <p>The transfer mode to use, e.g. Copy or Move.</p> <code>Copy</code> <code>overwrite</code> <code>bool</code> <p>If true, overwrite the file if it already exists at the destination.</p> <code>False</code> Source code in <code>prefect_managedfiletransfer/upload_file_flow.py</code> <pre><code>@flow(\n    name=CONSTANTS.FLOW_NAMES.UPLOAD_FILE,\n    log_prints=True,\n    flow_run_name=generate_flow_run_name,\n    retries=2,\n    retry_delay_seconds=60 * 20,  # retry every 20 minutes\n    timeout_seconds=60 * 30,  # timeout after 30 minutes\n)\nasync def upload_file_flow(\n    source_folder: Path,\n    pattern_to_upload: str,\n    destination_file: Path,\n    destination_block_or_blockname: (\n        ServerWithBasicAuthBlock\n        | ServerWithPublicKeyAuthBlock\n        | LocalFileSystem\n        | RCloneConfigFileBlock\n        | str\n    ),\n    update_only_if_newer_mode: bool = False,  # if true skip files that are newer on the destination\n    mode: TransferType = TransferType.Copy,\n    overwrite: bool = False,\n):\n    \"\"\"\n    Publish a single file to a destination, e.g. upload an image to a website or copy a file to a local shared public folder\n\n    Args:\n        source_folder (Path): The folder where the file to upload is located.\n        pattern_to_upload (str): The pattern of the file to upload, e.g. \"*.jpg\".\n        destination_file (Path): The destination file path where the file will be uploaded.\n        destination_block_or_blockname (ServerWithBasicAuthBlock | ServerWithPublicKeyAuthBlock | LocalFileSystem | RCloneConfigFileBlock | str): The destination block or block name where the file will be uploaded.\n        update_only_if_newer_mode (bool): If true, skip files that are newer on the destination.\n        mode (TransferType): The transfer mode to use, e.g. Copy or Move.\n        overwrite (bool): If true, overwrite the file if it already exists at the destination.\n    Returns:\n        None: The function does not return anything, it raises an exception if the upload fails.\n    Raises:\n        ValueError: If the destination block or blockname is missing, or if the upload fails.\n        TypeError: If the destination block is of an unsupported type.\n        ImportError: If the required libraries for SFTP or RClone are not installed.\n        FileNotFoundError: If the source folder or file to upload does not exist.\n        ConnectionError: If the connection to the SFTP server fails.\n        FileExistsError: If the destination file already exists and overwrite is False.\n        RuntimeError: if the upload occured but the sizes do not match, indicating a potential issue with the upload process.\n        RuntimeError: if the upload fails with a non-zero exit code.\n    \"\"\"\n\n    logger = get_run_logger()\n\n    sftp_details: ServerWithBasicAuthBlock | None = None\n    sftp_details_public_key: ServerWithPublicKeyAuthBlock | None = None\n    local_details: LocalFileSystem | None = None\n\n    if destination_block_or_blockname is None:\n        raise ValueError(\"Destination block or blockname is missing\")\n\n    destination_block: (\n        ServerWithBasicAuthBlock\n        | ServerWithPublicKeyAuthBlock\n        | LocalFileSystem\n        | RCloneConfigFileBlock\n    )\n    if isinstance(destination_block_or_blockname, str):\n        destination_block = await try_fetch_upload_destination(\n            destination_block_or_blockname\n        )\n    else:\n        destination_block = destination_block_or_blockname\n    result: int | None = None\n    if isinstance(destination_block, ServerWithBasicAuthBlock):\n        sftp_details = destination_block\n        if not sftp_details.isValid():\n            raise ValueError(\"One or more SFTP server details are missing\")\n        logger.info(\n            f\"Uploading {pattern_to_upload} to {destination_file} on {sftp_details.host}\"\n        )\n        result = await upload_asset(\n            source_folder=source_folder,\n            pattern_to_upload=pattern_to_upload,\n            destination_file=destination_file,\n            destination_type=RemoteConnectionType.SFTP,\n            host=sftp_details.host,\n            port=sftp_details.port,\n            username=sftp_details.username,\n            password=sftp_details.password.get_secret_value(),\n            update_only_if_newer_mode=update_only_if_newer_mode,\n            overwrite=overwrite,\n            mode=mode,\n        )\n    elif isinstance(destination_block, ServerWithPublicKeyAuthBlock):\n        sftp_details_public_key = destination_block\n        if not sftp_details_public_key.is_valid():\n            raise ValueError(\"One or more SFTP server details are missing\")\n        logger.info(\n            f\"Uploading {pattern_to_upload} to {destination_file} on {sftp_details_public_key.host} with pub/private keys\"\n        )\n        with sftp_details_public_key.get_temp_key_file() as temp_key_file:\n            result = await upload_asset(\n                source_folder=source_folder,\n                pattern_to_upload=pattern_to_upload,\n                destination_file=destination_file,\n                destination_type=RemoteConnectionType.SFTP,\n                host=sftp_details_public_key.host,\n                port=sftp_details_public_key.port,\n                username=sftp_details_public_key.username,\n                private_key_path=temp_key_file.get_path(),\n                update_only_if_newer_mode=update_only_if_newer_mode,\n                overwrite=overwrite,\n                mode=mode,\n            )\n    elif isinstance(destination_block, LocalFileSystem):\n        local_details = destination_block\n        if not local_details.basepath:\n            raise ValueError(\"LocalFileSystem.basepath details are missing\")\n        logger.debug(f\"Using basepath from local filesystem: {local_details.basepath}\")\n        destination_file = Path(local_details.basepath) / destination_file\n        logger.info(f\"Uploading to local filesystem: {destination_file}\")\n        result = await upload_asset(\n            source_folder=source_folder,\n            pattern_to_upload=pattern_to_upload,\n            destination_file=destination_file,\n            destination_type=RemoteConnectionType.LOCAL,\n            update_only_if_newer_mode=update_only_if_newer_mode,\n            overwrite=overwrite,\n            mode=mode,\n        )\n    elif isinstance(destination_block, RCloneConfigFileBlock):\n        rclone_details_prefect_block: RCloneConfigFileBlock = destination_block\n        logger.info(\n            f\"Uploading {pattern_to_upload} to {destination_file} using rclone block for remote {rclone_details_prefect_block.remote_name}\"\n        )\n\n        result = await upload_asset(\n            source_folder=source_folder,\n            pattern_to_upload=pattern_to_upload,\n            destination_file=destination_file,\n            destination_type=RemoteConnectionType.RCLONE,\n            rclone_config=RCloneConfigSavedInPrefect(rclone_details_prefect_block),\n            update_only_if_newer_mode=update_only_if_newer_mode,\n            overwrite=overwrite,\n            mode=mode,\n            logger=logger,\n        )\n\n    if result is None:\n        raise ValueError(\"Destination details are missing\")\n    if result != 0:\n        raise RuntimeError(\n            f\"Failed to upload {pattern_to_upload} to {destination_file}. Exit code {result}\"\n        )\n</code></pre>"},{"location":"tasks/","title":"Tasks","text":""},{"location":"tasks/#prefect_managedfiletransfer.download_file_task","title":"<code>prefect_managedfiletransfer.download_file_task</code>","text":""},{"location":"tasks/#prefect_managedfiletransfer.download_file_task-classes","title":"Classes","text":""},{"location":"tasks/#prefect_managedfiletransfer.download_file_task-functions","title":"Functions","text":""},{"location":"tasks/#prefect_managedfiletransfer.download_file_task.download_file_task","title":"<code>download_file_task</code>  <code>async</code>","text":"<p>Task to download a single file from a remote source (SFTP, RClone, or LocalFileSystem) to a local path Args:     source_block (TransferBlockType): The block representing the source connection.     source_type (RemoteConnectionType): The type of the source connection.     remote_asset (RemoteAsset): The remote asset to download.     target_file_path (Path): The path where the file should be downloaded.     update_only_if_newer_mode (bool): If true, skip files that are newer on the destination.     overwrite (bool): If true, overwrite the file if it exists.     mode (str): The transfer mode to use (e.g., Copy, Move).     rclone_config (RCloneConfigSavedInPrefect | None): The RClone configuration to use for the download, if applicable.     check_for_space (bool): If true, check if there is enough space on the destination.     check_for_space_overhead (int): The overhead space to consider when checking for space in bytes.     reference_date (datetime | None): The reference date to use for checking file modification times. Defaults to None, which uses the current time. Returns:     AssetDownloadResult: The result of the download operation, including success status and any error messages.</p> Source code in <code>prefect_managedfiletransfer/download_file_task.py</code> <pre><code>@task(\n    retries=2,\n    retry_delay_seconds=60,\n    timeout_seconds=60 * 30,\n    task_run_name=\"download-{remote_asset.path}\",\n)\nasync def download_file_task(\n    source_block: TransferBlockType,\n    source_type: RemoteConnectionType,\n    remote_asset: RemoteAsset,\n    target_file_path: Path,\n    update_only_if_newer_mode: bool,\n    overwrite: bool,\n    mode: str,\n    rclone_config: RCloneConfigSavedInPrefect | None,\n    check_for_space: bool,\n    check_for_space_overhead: int,\n    reference_date: datetime | None = None,\n) -&gt; AssetDownloadResult:\n    \"\"\"\n    Task to download a single file from a remote source (SFTP, RClone, or LocalFileSystem) to a local path\n    Args:\n        source_block (TransferBlockType): The block representing the source connection.\n        source_type (RemoteConnectionType): The type of the source connection.\n        remote_asset (RemoteAsset): The remote asset to download.\n        target_file_path (Path): The path where the file should be downloaded.\n        update_only_if_newer_mode (bool): If true, skip files that are newer on the destination.\n        overwrite (bool): If true, overwrite the file if it exists.\n        mode (str): The transfer mode to use (e.g., Copy, Move).\n        rclone_config (RCloneConfigSavedInPrefect | None): The RClone configuration to use for the download, if applicable.\n        check_for_space (bool): If true, check if there is enough space on the destination.\n        check_for_space_overhead (int): The overhead space to consider when checking for space in bytes.\n        reference_date (datetime | None): The reference date to use for checking file modification times. Defaults to None, which uses the current time.\n    Returns:\n        AssetDownloadResult: The result of the download operation, including success status and any error messages.\n    \"\"\"\n\n    logger.info(f\"Start download {remote_asset.path} to {target_file_path}\")\n\n    if not reference_date:\n        reference_date = datetime.now(timezone.utc)\n\n    with (\n        source_block.get_temp_key_file()\n        if hasattr(source_block, \"get_temp_key_file\")\n        else nullcontext()\n    ) as temp_key_file:\n        download_result = await download_asset(\n            file=remote_asset,\n            destination_path=target_file_path,\n            remote_type=source_type,\n            host=source_block.host if hasattr(source_block, \"host\") else None,\n            port=source_block.port if hasattr(source_block, \"port\") else None,\n            username=(\n                source_block.username if hasattr(source_block, \"username\") else None\n            ),\n            password=(\n                source_block.password if hasattr(source_block, \"password\") else None\n            ),\n            private_key_path=(temp_key_file.get_path() if temp_key_file else None),\n            rclone_config=rclone_config,\n            update_only_if_newer_mode=update_only_if_newer_mode,\n            overwrite=overwrite,\n            check_for_space=check_for_space,\n            check_for_space_overhead=check_for_space_overhead,\n            mode=mode,\n            reference_date=reference_date,\n        )\n        if not download_result.success:\n            logger.error(\n                f\"Failed to download {remote_asset.path}: {download_result.error}\"\n            )\n            raise Exception(download_result.error)\n\n        return download_result\n</code></pre>"},{"location":"tasks/#prefect_managedfiletransfer.list_remote_files_task","title":"<code>prefect_managedfiletransfer.list_remote_files_task</code>","text":""},{"location":"tasks/#prefect_managedfiletransfer.list_remote_files_task-classes","title":"Classes","text":""},{"location":"tasks/#prefect_managedfiletransfer.list_remote_files_task-functions","title":"Functions","text":""},{"location":"tasks/#prefect_managedfiletransfer.list_remote_files_task.list_remote_files_task","title":"<code>list_remote_files_task</code>  <code>async</code>","text":"<p>Task to list remote files based on a matcher. Remote can be SFTP, RClone, or LocalFileSystem.</p> <p>Parameters:</p> Name Type Description Default <code>source_block</code> <code>TransferBlockType</code> <p>The block representing the source connection.</p> required <code>source_type</code> <code>RemoteConnectionType</code> <p>The type of the source connection.</p> required <code>matcher</code> <code>FileMatcher</code> <p>The matcher defining the pattern to match files.</p> required <code>rclone_config</code> <code>RCloneConfigSavedInPrefect | None</code> <p>The RClone configuration to use for the remote connection, if applicable.</p> <code>None</code> <code>reference_date</code> <code>datetime | None</code> <p>The reference date to use for filtering files. Defaults to None, which uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RemoteAsset]</code> <p>list[RemoteAsset]: A list of RemoteAsset objects that match the given pattern.</p> Source code in <code>prefect_managedfiletransfer/list_remote_files_task.py</code> <pre><code>@task(task_run_name=\"list_{matcher.source_folder}_{matcher.pattern_to_match}\")\nasync def list_remote_files_task(\n    source_block: TransferBlockType,\n    source_type: RemoteConnectionType,\n    matcher: FileMatcher,\n    rclone_config: RCloneConfigSavedInPrefect | None = None,\n    reference_date: datetime | None = None,\n) -&gt; list[RemoteAsset]:\n    \"\"\"\n    Task to list remote files based on a matcher. Remote can be SFTP, RClone, or LocalFileSystem.\n\n    Args:\n        source_block (TransferBlockType): The block representing the source connection.\n        source_type (RemoteConnectionType): The type of the source connection.\n        matcher (FileMatcher): The matcher defining the pattern to match files.\n        rclone_config (RCloneConfigSavedInPrefect | None): The RClone configuration to use for the remote connection, if applicable.\n        reference_date (datetime | None): The reference date to use for filtering files. Defaults to None, which uses the current time.\n\n    Returns:\n        list[RemoteAsset]: A list of RemoteAsset objects that match the given pattern.\n    \"\"\"\n\n    basepath_str = source_block.basepath if hasattr(source_block, \"basepath\") else None\n    remote_source_path = PathUtil.resolve_path(\n        source_type, basepath_str, matcher.source_folder\n    )\n\n    if reference_date is None:\n        reference_date = datetime.now(timezone.utc)\n\n    logger.debug(f\"Listing remote files in {remote_source_path} with matcher {matcher}\")\n\n    files: list[RemoteAsset] = []\n    with (\n        source_block.get_temp_key_file()\n        if hasattr(source_block, \"get_temp_key_file\")\n        else nullcontext()\n    ) as temp_key_file:\n        found = await list_remote_assets(\n            remote_folder=remote_source_path,\n            pattern_to_match=matcher.pattern_to_match,\n            remote_type=source_type,\n            host=source_block.host if hasattr(source_block, \"host\") else None,\n            port=source_block.port if hasattr(source_block, \"port\") else None,\n            username=(\n                source_block.username if hasattr(source_block, \"username\") else None\n            ),\n            password=(\n                source_block.password if hasattr(source_block, \"password\") else None\n            ),\n            private_key_path=(temp_key_file.get_path() if temp_key_file else None),\n            rclone_config=rclone_config,\n            minimum_age=matcher.minimum_age,\n            maximum_age=matcher.maximum_age,\n            sort=matcher.sort,\n            skip=matcher.skip,\n            take=matcher.take,\n            reference_date=reference_date,\n        )\n        files.extend(found)\n\n    logger.info(\n        f\"Found {len(files)} remote files in {remote_source_path} with matcher {matcher}\"\n    )\n\n    return files\n</code></pre>"},{"location":"tasks/#prefect_managedfiletransfer.upload_file_task","title":"<code>prefect_managedfiletransfer.upload_file_task</code>","text":""},{"location":"tasks/#prefect_managedfiletransfer.upload_file_task-classes","title":"Classes","text":""},{"location":"tasks/#prefect_managedfiletransfer.upload_file_task-functions","title":"Functions","text":""},{"location":"tasks/#prefect_managedfiletransfer.upload_file_task.upload_file_task","title":"<code>upload_file_task</code>  <code>async</code>","text":"<p>Task to upload a single file to a remote destination (local/SFTP/RClone remote).</p> <p>Parameters:</p> Name Type Description Default <code>source_remote_asset</code> <code>RemoteAsset</code> <p>The remote asset to upload.</p> required <code>destination_block</code> <code>ServerWithBasicAuthBlock | ServerWithPublicKeyAuthBlock | LocalFileSystem | RCloneConfigFileBlock</code> <p>The block representing the destination.</p> required <code>destination_type</code> <code>RemoteConnectionType</code> <p>The type of the destination connection.</p> required <code>target_file_path</code> <code>Path</code> <p>The path where the file should be uploaded.</p> required <code>update_only_if_newer_mode</code> <code>bool</code> <p>If true, skip files that are newer on the destination.</p> required <code>overwrite</code> <code>bool</code> <p>If true, overwrite the file if it exists.</p> required <code>mode</code> <code>TransferType</code> <p>The transfer mode to use (e.g., Copy, Move).</p> required <code>rclone_config</code> <code>RCloneConfigFileBlock</code> <p>The RClone configuration block to use for the upload.</p> required <code>check_for_space</code> <code>bool</code> <p>If true, check if there is enough space on the destination.</p> required <code>check_for_space_overhead</code> <code>int</code> <p>The overhead space to consider when checking for space in bytes.</p> required <code>reference_date</code> <code>datetime</code> <p>now() in UTC. The reference date to use for checking file modification times. Used in testing.</p> required Source code in <code>prefect_managedfiletransfer/upload_file_task.py</code> <pre><code>@task(\n    retries=2,\n    retry_delay_seconds=60,\n    timeout_seconds=60 * 30,\n    task_run_name=\"upload-{target_file_path}\",\n)\nasync def upload_file_task(\n    source_remote_asset: RemoteAsset,\n    destination_block: (\n        ServerWithBasicAuthBlock\n        | ServerWithPublicKeyAuthBlock\n        | LocalFileSystem\n        | RCloneConfigFileBlock\n    ),\n    destination_type: RemoteConnectionType,\n    target_file_path: Path,\n    update_only_if_newer_mode: bool,\n    overwrite: bool,\n    mode: TransferType,\n    rclone_config: RCloneConfigFileBlock,\n    check_for_space: bool,\n    check_for_space_overhead: int,\n    reference_date: datetime,\n) -&gt; Path:\n    \"\"\"\n    Task to upload a single file to a remote destination (local/SFTP/RClone remote).\n\n    Args:\n        source_remote_asset (RemoteAsset): The remote asset to upload.\n        destination_block (ServerWithBasicAuthBlock | ServerWithPublicKeyAuthBlock | LocalFileSystem | RCloneConfigFileBlock): The block representing the destination.\n        destination_type (RemoteConnectionType): The type of the destination connection.\n        target_file_path (Path): The path where the file should be uploaded.\n        update_only_if_newer_mode (bool): If true, skip files that are newer on the destination.\n        overwrite (bool): If true, overwrite the file if it exists.\n        mode (TransferType): The transfer mode to use (e.g., Copy, Move).\n        rclone_config (RCloneConfigFileBlock): The RClone configuration block to use for the upload.\n        check_for_space (bool): If true, check if there is enough space on the destination.\n        check_for_space_overhead (int): The overhead space to consider when checking for space in bytes.\n        reference_date (datetime): now() in UTC. The reference date to use for checking file modification times. Used in testing.\n    Returns:\n        Path: The path to the uploaded file.\n    \"\"\"\n\n    logger.info(f\"Start upload {source_remote_asset.path} to {target_file_path}\")\n\n    with (\n        destination_block.get_temp_key_file()\n        if hasattr(destination_block, \"get_temp_key_file\")\n        else nullcontext()\n    ) as temp_key_file:\n        upload_result = await upload_asset(\n            source_folder=source_remote_asset.path.parent,\n            pattern_to_upload=source_remote_asset.path.name,\n            destination_file=target_file_path,\n            destination_type=destination_type,\n            host=(\n                destination_block.host if hasattr(destination_block, \"host\") else None\n            ),\n            port=(\n                destination_block.port if hasattr(destination_block, \"port\") else None\n            ),\n            username=(\n                destination_block.username\n                if hasattr(destination_block, \"username\")\n                else None\n            ),\n            password=(\n                destination_block.password\n                if hasattr(destination_block, \"password\")\n                else None\n            ),\n            private_key_path=(temp_key_file.get_path() if temp_key_file else None),\n            rclone_config=rclone_config,\n            update_only_if_newer_mode=update_only_if_newer_mode,\n            overwrite=overwrite,\n            mode=mode,\n            check_for_space=check_for_space,\n            check_for_space_overhead=check_for_space_overhead,\n            reference_datetime=reference_date,\n        )\n        if upload_result != 0:\n            logger.error(\n                f\"Failed to upload {source_remote_asset.path} to {target_file_path}. Exit code {upload_result}\"\n            )\n            raise Exception(\"Upload failed\")\n\n        return target_file_path\n</code></pre>"}]}